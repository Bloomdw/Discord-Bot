/**
 * win32-def
 * win32 definitions for node-ffi
 *
 * @version 9.3.0
 * @author waiting
 * @license MIT
 * @link https://waitingsong.github.io/node-win32-api
 */

// dict of windef value
const _WIN64_HOLDER = '_WIN64_HOLDER_';
const _UNICODE_HOLDER = '_UNICODE_HOLDER_';
const windefSkipKeys = new Set(['macroMap']);
/* istanbul ignore next */
const _WIN64 = process.arch === 'x64';
/* istanbul ignore next */
const _UNICODE = true;
const settingsDefault = {
    singleton: true,
    _UNICODE,
    _WIN64,
};
// for validation
const windefSet = new Set([
    'bool',
    'bool*',
    'byte',
    'byte*',
    'char',
    'uchar',
    'char*',
    'float',
    'float*',
    'int',
    'int8',
    'int16',
    'int32',
    'int64',
    'int*',
    'int8*',
    'int16*',
    'int32*',
    'int64*',
    'uint',
    'uint8',
    'uint16',
    'uint32',
    'uint64',
    'uint*',
    'uint8*',
    'uint16*',
    'uint32*',
    'uint64*',
    'int**',
    'uint**',
    'uint32**',
    'uint64**',
    'long',
    'longlong',
    'long*',
    'longlong*',
    'pointer',
    'ushort',
    'void',
    'void*',
]);

var config = /*#__PURE__*/Object.freeze({
    __proto__: null,
    _WIN64_HOLDER: _WIN64_HOLDER,
    _UNICODE_HOLDER: _UNICODE_HOLDER,
    windefSkipKeys: windefSkipKeys,
    _WIN64: _WIN64,
    _UNICODE: _UNICODE,
    settingsDefault: settingsDefault,
    windefSet: windefSet
});

// convert macro variable of windef
function parse_windef(windefObj, macroMap, settings) {
    const ww = clone_filter_windef(windefObj); // output without macroMap
    const macroSrc = prepare_macro(macroMap, settings);
    const ret = prepare_windef_ref(ww, macroSrc);
    validateWinData(ret, windefSet);
    return ret;
}
/**
 * convert typeof array of param to string
 * such like ['_WIN64_HOLDER_', 'int64', 'int32'], no changed returning when string
 */
function parse_param_placeholder(param, settings) {
    if (typeof param === 'string') {
        return param;
    }
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    else if (!param) {
        throw new Error('parse_param_placeholder(ps, settings) value of ps invalid');
    }
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    else if (!Array.isArray(param) || param.length !== 3) {
        throw new Error('parse_param_placeholder(ps, settings) value of ps must Array and has THREE elements');
    }
    const st = parse_settings(settings);
    let ps = '';
    switch (param[0]) {
        case _WIN64_HOLDER:
            ps = parse_placeholder_arch(param, st._WIN64);
            break;
        case _UNICODE_HOLDER:
            ps = parse_placeholder_unicode(param, st._UNICODE);
            break;
        default:
            throw new Error('the value of param placeholder invlaid:' + param[0]);
    }
    return ps;
}
// convert param like ['_WIN64_HOLDER_', 'int64', 'int32] to 'int64' or 'int32'
function parse_placeholder_arch(param, _WIN64) {
    if (typeof param === 'string') {
        return param;
    }
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    else if (!param || param.length !== 3) {
        throw new Error('_WIN64 macro should be Array and has 3 items');
    }
    return _WIN64 ? param[1] : param[2];
}
// convert param like ['_UNICODE_HOLDER_', 'uint16*', 'uint8*'] to 'uint16*' or 'uint8*'
function parse_placeholder_unicode(param, _UNICODE) {
    if (typeof param === 'string') {
        return param;
    }
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    else if (!param || param.length !== 3) {
        throw new Error('_UNICODE macro should be Array and has 3 items');
    }
    return _UNICODE ? param[1] : param[2];
}
/**
 * parse ['_WIN64_HOLDER', 'int64*', 'int32*'] to 'int64*' or 'int32'
 * or ['_UNICODE_HOLDER_', 'uint16*', 'uint8*'] to 'uint16*' or 'uint8*'
 */
function prepare_macro(macroMap, settings) {
    const ret = new Map();
    // v string|array
    for (const [k, v] of macroMap.entries()) {
        ret.set(k, parse_param_placeholder(v, settings));
    }
    return ret;
}
/**
 * parse const HANDLE = 'PVOID' to the realy FFIParam (like 'uint32*')
 * macroMap <['PVOID', 'uint32*'], ...>
 */
function prepare_windef_ref(ww, macroSrc) {
    const ret = {};
    const map = new Map();
    // first loop paser keys which exists in macroSrc
    for (const x of Object.keys(ww)) {
        /* istanbul ignore next */
        if (map.has(x)) {
            continue;
        }
        if (macroSrc.has(x)) { // PVOID:_WIN64_HOLDER -> PVOID:'uint64*'
            const vv = macroSrc.get(x);
            if (vv) {
                map.set(x, vv);
            }
            else {
                throw new Error(`Value of macroSrc item "${x}" blank`);
            }
        }
        else {
            continue; // not throw error
        }
    }
    // 2nd loop paser key , maybe value refer other key
    for (const [k, v] of Object.entries(ww)) {
        /* istanbul ignore next */
        if (map.has(k)) {
            continue;
        }
        if (typeof v === 'string') {
            if (windefSet.has(v)) {
                map.set(k, v);
            }
            else {
                const value = lookupRef(v, ww, macroSrc);
                // tslint:disable-next-line
                if (typeof value === 'string' && value) {
                    map.set(k, value);
                }
                else {
                    map.set(k, v); // maybe invalid for windefSet, will validateWinData() later
                }
            }
        }
        else {
            throw new Error(`prepare_windef_ref() missing entry for k/v: ${k}/"N/A"`);
        }
    }
    map.forEach((v, k) => {
        ret[k] = v;
    });
    return ret;
}
function clone_filter_windef(windef) {
    const ret = {};
    for (const x of Object.keys(windef)) {
        if (typeof windef[x] === 'string') {
            Object.defineProperty(ret, x, {
                value: windef[x],
                writable: true,
                enumerable: true,
                configurable: true,
            });
        }
        else {
            throw new Error(`typeof value of ${x} NOT string`);
        }
    }
    return ret;
}
function parse_settings(settings) {
    const st = { ...settingsDefault };
    if (typeof settings !== 'undefined' && Object.keys(settings).length) {
        Object.assign(st, settings);
    }
    return st;
}
function lookupRef(key, ww, macroSrc) {
    let ret = _lookupRef(key, ww, macroSrc);
    if (!ret) {
        return '';
    }
    for (let i = 0, len = 3; i < len; i += 1) {
        const tmp = _lookupRef(ret, ww, macroSrc);
        if (tmp) {
            ret = tmp;
        }
        else {
            break;
        }
    }
    return ret;
}
function _lookupRef(key, ww, macroSrc) {
    if (macroSrc.has(key)) {
        return macroSrc.get(key);
    }
    // key is not valid FFIParam such 'int/uint...', like HMODULE: 'HANDLE'
    if (typeof ww[key] === 'string') {
        // parse HANDLE: 'PVOID' , PVOID already parsed
        const ret = ww[key];
        if (ret && macroSrc.has(ret)) { //  HANDLE:PVOID, macroSrc has PVOID
            return macroSrc.get(ret);
        }
        return ret;
    }
    return '';
}
// valid parsed value exists in windefSet
function isValidDataDef(key, srcSet) {
    return !!srcSet.has(key);
}
function validateWinData(windef, srcSet) {
    for (const [k, v] of Object.entries(windef)) {
        if (!k || !v) {
            throw new Error(`validateWinData() k or v empty: "${k}"/"${v}"`);
        }
        if (typeof v !== 'string') {
            throw new Error(`validateWinData() v not typeof string: "${k}"/"N/A"`);
        }
        if (!isValidDataDef(v, srcSet)) {
            throw new Error(`validateWinData() value is invalid ffi param value: "${k}"/"${v}", may extra space`);
        }
    }
}

// windows data types for ref module https://github.com/TooTallNate/ref
/**
 * macro convert method
 * _WIN64_HOLDER or _UNICODE_HOLDER
 *
 * demo: const PVOID = _WIN64_HOLDER;
 */
const ATOM = 'uint16';
const DWORD = 'uint32';
const PVOID = _WIN64_HOLDER;
/**
 * `uint32` or `uint64` used as value usage (memory address) instead of PVOID (Buffer),
 * Use `HANDLE` (number) for params defintion of the api,
 * @see https://stackoverflow.com/questions/18266626/what-is-the-range-of-a-windows-handle-on-a-64-bits-application/29526711#29526711
 */
const HANDLE = _WIN64_HOLDER;
/**
 * `HANDLE_PVOID` (Buffer) can be used for definition of Struct,
 */
const HANDLE_PVOID = 'PVOID';
const LONG_PTR = _WIN64_HOLDER;
const ULONG_PTR = _WIN64_HOLDER;
const VOID = 'void';
const WCHAR = 'uint16';
const WORD = 'int16';
const BOOL = 'int';
const BOOLEAN = 'bool';
const BYTE = 'byte';
const CALLBACK = 'pointer'; // https://msdn.microsoft.com/en-us/library/windows/desktop/ms633573(v=vs.85).aspx
const CCHAR = 'uint8';
const CHAR = 'uint8';
const COLORREF = 'DWORD';
// export const CONST;
const DWORDLONG = 'uint64';
const DWORD_PTR = 'ULONG_PTR';
const DWORD32 = 'uint32';
const DWORD64 = 'uint64';
const FLOAT = 'float';
const HACCEL = 'HANDLE';
const HALF_PTR = _WIN64_HOLDER;
const HBITMAP = 'HANDLE';
const HBRUSH = 'HANDLE';
const HCOLORSPACE = 'HANDLE';
const HCONV = 'HANDLE';
const HCONVLIST = 'HANDLE';
const HCURSOR = 'HANDLE';
const HDC = 'HANDLE';
const HDDEDATA = 'HANDLE';
const HDESK = 'HANDLE';
const HDROP = 'HANDLE';
const HDWP = 'HANDLE';
const HENHMETAFILE = 'HANDLE';
const HFILE = 'HANDLE'; // typedef int HFILE;
const HFONT = 'HANDLE';
const HGDIOBJ = 'HANDLE';
const HGLOBAL = 'HANDLE';
const HHOOK = 'HANDLE';
const HICON = 'HANDLE';
const HINSTANCE = 'HANDLE';
const HKEY = 'HANDLE';
const HKL = 'HANDLE';
const HLOCAL = 'HANDLE';
const HMENU = 'HANDLE';
const HMETAFILE = 'HANDLE';
const HMODULE = HINSTANCE;
const HMONITOR = 'HANDLE';
const HPALETTE = 'HANDLE';
const HPEN = 'HANDLE';
const HRESULT = 'long';
const HRGN = 'HANDLE';
const HRSRC = 'HANDLE';
const HSZ = 'HANDLE';
const HWINEVENTHOOK = 'HANDLE';
const HWINSTA = 'HANDLE';
const HWND = 'HANDLE';
/** A 32-bit signed integer */
const INT = 'int';
const INT_PTR = _WIN64_HOLDER;
const INT8 = 'int8';
const INT16 = 'int16';
const INT32 = 'int32';
const INT64 = 'int64';
const LANGID = 'WORD';
const LCID = 'DWORD';
const LCTYPE = 'DWORD';
const LGRPID = 'DWORD';
const LONG = 'long';
const LONGLONG = 'longlong';
const LONG32 = 'int32';
const LONG64 = 'int64';
const LPARAM = 'LONG_PTR';
const LPBOOL = 'BOOL';
const LPBYTE = 'byte*';
const LPCOLORREF = 'DWORD';
const LPCSTR = 'uint8*';
const LPCWSTR = 'uint16*';
const LPCTSTR = _UNICODE_HOLDER;
const LPVOID = 'void*';
const LPCVOID = 'LPVOID';
const LPDWORD = 'uint16*';
const LPHANDLE = _WIN64_HOLDER; // A pointer to a HANDLE.
const LPINT = 'int*';
const LPLONG = 'int32*';
const LPMSG = 'pointer'; // A pointer to a MSG
const LPPOINT = 'pointer';
const LPSTR = 'char*';
const LPWSTR = 'uint16*';
const LPTSTR = _UNICODE_HOLDER;
const LPWORD = 'uint16*';
const LRESULT = 'LONG_PTR';
const NTSTATUS = 'uint32';
const PBOOL = 'int*'; // ? 'bool*'
const PBOOLEAN = 'bool*';
const PBYTE = 'byte*';
const PCHAR = 'char*';
const PCSTR = 'uint8*';
const PCTSTR = _WIN64_HOLDER;
const PCWSTR = 'uint16*';
const PDWORD = 'uint32*';
const PDWORDLONG = 'uint64*';
const PDWORD_PTR = 'DWORD_PTR';
const PDWORD32 = 'uint32*';
const PDWORD64 = 'uint64*';
const PFLOAT = 'float*';
const PHALF_PTR = 'pointer'; // ? A pointer to a HALF_PTR.
const PHANDLE = _WIN64_HOLDER;
const PHKEY = _WIN64_HOLDER;
const PINT = 'int*';
const PINT_PTR = 'int**';
const PINT8 = 'int8*';
const PINT16 = 'int16*';
const PINT32 = 'int32*';
const PINT64 = 'int64*';
const PLCID = 'uint32*';
const PLONG = 'long*';
const PLONGLONG = 'int64*';
const PLONG_PTR = 'pointer';
const PLONG32 = 'int32*';
const PLONG64 = 'int64*';
// ? A 32-bit pointer. On a 32-bit system, this is a native pointer.
// On a 64-bit system, this is a truncated 64-bit pointer.
const POINTER_32 = _WIN64_HOLDER;
// ? A 64-bit pointer. On a 64-bit system, this is a native pointer.
// On a 32-bit system, this is a sign-extended 32-bit pointer.
const POINTER_64 = _WIN64_HOLDER;
const POINTER_SIGNED = 'pointer'; // ? A signed pointer.
const POINTER_UNSIGNED = 'pointer'; // An unsigned pointer.
const PSHORT = 'int16*';
const PSIZE_T = 'ULONG_PTR'; // ?
const PSSIZE_T = 'pointer';
const PSTR = 'char*';
const PTBYTE = _UNICODE_HOLDER;
const PTCHAR = _UNICODE_HOLDER;
const PTSTR = _UNICODE_HOLDER;
const PUCHAR = 'pointer';
const PUHALF_PTR = 'pointer';
const PUINT = 'uint*';
const PUINT_PTR = 'uint**';
const PUINT8 = 'uint8*';
const PUINT16 = 'uint16*';
const PUINT32 = 'uint32*';
const PUINT64 = 'uint64*';
const PULONG = 'uint*';
const PULONGLONG = 'uint64*';
const PULONG_PTR = 'uint64**';
const PULONG32 = 'uint*';
const PULONG64 = 'uint64*';
const PUSHORT = 'uint16*';
const PWCHAR = 'uint16*';
const PWORD = 'uint16*';
const PWSTR = 'uint16*';
const QWORD = 'uint64';
const SC_HANDLE = 'HANDLE';
const SC_LOCK = 'LPVOID';
const SERVICE_STATUS_HANDLE = 'HANDLE';
const SHORT = 'int16';
const SIZE_T = 'ULONG_PTR';
const SSIZE_T = 'LONG_PTR';
const TBYTE = _UNICODE_HOLDER;
const TCHAR = _UNICODE_HOLDER;
const UCHAR = 'uchar';
const UHALF_PTR = _WIN64_HOLDER;
const UINT = 'uint';
const UINT_PTR = _WIN64_HOLDER;
const UINT8 = 'uint8';
const UINT16 = 'uint16';
const UINT32 = 'uint32';
const UINT64 = 'uint64';
const ULONG = 'uint';
const ULONGLONG = 'uint64';
const ULONG32 = 'uint32';
const ULONG64 = 'uint64';
const UNICODE_STRING = 'pointer';
const USHORT = 'ushort';
const USN = LONGLONG;
// export const WINAPI;
const WINEVENTPROC = 'pointer';
const WNDENUMPROC = 'pointer';
const WNDPROC = 'pointer';
/**
 * Note: original be typedef UINT_PTR WPARAM;
 * CALLBACK WNDCLASSEX.lpfnWndProc may pass negative number and cause process exit.
 */
const WPARAM = 'UINT_PTR';
// A pointer to an INITCOMMONCONTROLSEX
const LPINITCOMMONCONTROLSEX = 'pointer';
const LPWNDCLASSEX = 'pointer'; // A pointer to a WNDCLASSEX
const PWINDOWINFO = 'pointer'; // A pointer to a WINDOWINFO structure
const PFILETIME = 'pointer'; // A pointer to a FILETIME
const LPFILETIME = 'pointer'; // A pointer to a FILETIME
const va_list = 'char*';
/* ------------------ struct ---------------------- */
const INITCOMMONCONTROLSEX = 'pointer';
const MSG = 'pointer';
const POINT = 'pointer';
const WNDCLASSEX = 'pointer';
const WINDOWINFO = 'pointer';
const PRAWINPUTDEVICELIST = 'pointer';
const RECT = 'pointer'; // _RECT

var windef = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ATOM: ATOM,
    DWORD: DWORD,
    PVOID: PVOID,
    HANDLE: HANDLE,
    HANDLE_PVOID: HANDLE_PVOID,
    LONG_PTR: LONG_PTR,
    ULONG_PTR: ULONG_PTR,
    VOID: VOID,
    WCHAR: WCHAR,
    WORD: WORD,
    BOOL: BOOL,
    BOOLEAN: BOOLEAN,
    BYTE: BYTE,
    CALLBACK: CALLBACK,
    CCHAR: CCHAR,
    CHAR: CHAR,
    COLORREF: COLORREF,
    DWORDLONG: DWORDLONG,
    DWORD_PTR: DWORD_PTR,
    DWORD32: DWORD32,
    DWORD64: DWORD64,
    FLOAT: FLOAT,
    HACCEL: HACCEL,
    HALF_PTR: HALF_PTR,
    HBITMAP: HBITMAP,
    HBRUSH: HBRUSH,
    HCOLORSPACE: HCOLORSPACE,
    HCONV: HCONV,
    HCONVLIST: HCONVLIST,
    HCURSOR: HCURSOR,
    HDC: HDC,
    HDDEDATA: HDDEDATA,
    HDESK: HDESK,
    HDROP: HDROP,
    HDWP: HDWP,
    HENHMETAFILE: HENHMETAFILE,
    HFILE: HFILE,
    HFONT: HFONT,
    HGDIOBJ: HGDIOBJ,
    HGLOBAL: HGLOBAL,
    HHOOK: HHOOK,
    HICON: HICON,
    HINSTANCE: HINSTANCE,
    HKEY: HKEY,
    HKL: HKL,
    HLOCAL: HLOCAL,
    HMENU: HMENU,
    HMETAFILE: HMETAFILE,
    HMODULE: HMODULE,
    HMONITOR: HMONITOR,
    HPALETTE: HPALETTE,
    HPEN: HPEN,
    HRESULT: HRESULT,
    HRGN: HRGN,
    HRSRC: HRSRC,
    HSZ: HSZ,
    HWINEVENTHOOK: HWINEVENTHOOK,
    HWINSTA: HWINSTA,
    HWND: HWND,
    INT: INT,
    INT_PTR: INT_PTR,
    INT8: INT8,
    INT16: INT16,
    INT32: INT32,
    INT64: INT64,
    LANGID: LANGID,
    LCID: LCID,
    LCTYPE: LCTYPE,
    LGRPID: LGRPID,
    LONG: LONG,
    LONGLONG: LONGLONG,
    LONG32: LONG32,
    LONG64: LONG64,
    LPARAM: LPARAM,
    LPBOOL: LPBOOL,
    LPBYTE: LPBYTE,
    LPCOLORREF: LPCOLORREF,
    LPCSTR: LPCSTR,
    LPCWSTR: LPCWSTR,
    LPCTSTR: LPCTSTR,
    LPVOID: LPVOID,
    LPCVOID: LPCVOID,
    LPDWORD: LPDWORD,
    LPHANDLE: LPHANDLE,
    LPINT: LPINT,
    LPLONG: LPLONG,
    LPMSG: LPMSG,
    LPPOINT: LPPOINT,
    LPSTR: LPSTR,
    LPWSTR: LPWSTR,
    LPTSTR: LPTSTR,
    LPWORD: LPWORD,
    LRESULT: LRESULT,
    NTSTATUS: NTSTATUS,
    PBOOL: PBOOL,
    PBOOLEAN: PBOOLEAN,
    PBYTE: PBYTE,
    PCHAR: PCHAR,
    PCSTR: PCSTR,
    PCTSTR: PCTSTR,
    PCWSTR: PCWSTR,
    PDWORD: PDWORD,
    PDWORDLONG: PDWORDLONG,
    PDWORD_PTR: PDWORD_PTR,
    PDWORD32: PDWORD32,
    PDWORD64: PDWORD64,
    PFLOAT: PFLOAT,
    PHALF_PTR: PHALF_PTR,
    PHANDLE: PHANDLE,
    PHKEY: PHKEY,
    PINT: PINT,
    PINT_PTR: PINT_PTR,
    PINT8: PINT8,
    PINT16: PINT16,
    PINT32: PINT32,
    PINT64: PINT64,
    PLCID: PLCID,
    PLONG: PLONG,
    PLONGLONG: PLONGLONG,
    PLONG_PTR: PLONG_PTR,
    PLONG32: PLONG32,
    PLONG64: PLONG64,
    POINTER_32: POINTER_32,
    POINTER_64: POINTER_64,
    POINTER_SIGNED: POINTER_SIGNED,
    POINTER_UNSIGNED: POINTER_UNSIGNED,
    PSHORT: PSHORT,
    PSIZE_T: PSIZE_T,
    PSSIZE_T: PSSIZE_T,
    PSTR: PSTR,
    PTBYTE: PTBYTE,
    PTCHAR: PTCHAR,
    PTSTR: PTSTR,
    PUCHAR: PUCHAR,
    PUHALF_PTR: PUHALF_PTR,
    PUINT: PUINT,
    PUINT_PTR: PUINT_PTR,
    PUINT8: PUINT8,
    PUINT16: PUINT16,
    PUINT32: PUINT32,
    PUINT64: PUINT64,
    PULONG: PULONG,
    PULONGLONG: PULONGLONG,
    PULONG_PTR: PULONG_PTR,
    PULONG32: PULONG32,
    PULONG64: PULONG64,
    PUSHORT: PUSHORT,
    PWCHAR: PWCHAR,
    PWORD: PWORD,
    PWSTR: PWSTR,
    QWORD: QWORD,
    SC_HANDLE: SC_HANDLE,
    SC_LOCK: SC_LOCK,
    SERVICE_STATUS_HANDLE: SERVICE_STATUS_HANDLE,
    SHORT: SHORT,
    SIZE_T: SIZE_T,
    SSIZE_T: SSIZE_T,
    TBYTE: TBYTE,
    TCHAR: TCHAR,
    UCHAR: UCHAR,
    UHALF_PTR: UHALF_PTR,
    UINT: UINT,
    UINT_PTR: UINT_PTR,
    UINT8: UINT8,
    UINT16: UINT16,
    UINT32: UINT32,
    UINT64: UINT64,
    ULONG: ULONG,
    ULONGLONG: ULONGLONG,
    ULONG32: ULONG32,
    ULONG64: ULONG64,
    UNICODE_STRING: UNICODE_STRING,
    USHORT: USHORT,
    USN: USN,
    WINEVENTPROC: WINEVENTPROC,
    WNDENUMPROC: WNDENUMPROC,
    WNDPROC: WNDPROC,
    WPARAM: WPARAM,
    LPINITCOMMONCONTROLSEX: LPINITCOMMONCONTROLSEX,
    LPWNDCLASSEX: LPWNDCLASSEX,
    PWINDOWINFO: PWINDOWINFO,
    PFILETIME: PFILETIME,
    LPFILETIME: LPFILETIME,
    va_list: va_list,
    INITCOMMONCONTROLSEX: INITCOMMONCONTROLSEX,
    MSG: MSG,
    POINT: POINT,
    WNDCLASSEX: WNDCLASSEX,
    WINDOWINFO: WINDOWINFO,
    PRAWINPUTDEVICELIST: PRAWINPUTDEVICELIST,
    RECT: RECT
});

const macroMap = new Map([
    ['HANDLE', [_WIN64_HOLDER, 'uint64', 'uint32']],
    ['PVOID', [_WIN64_HOLDER, 'uint64*', 'uint32*']],
    ['HALF_PTR', [_WIN64_HOLDER, 'int32', 'int16']],
    ['INT_PTR', [_WIN64_HOLDER, 'int64', 'int32']],
    ['LONG_PTR', [_WIN64_HOLDER, 'int64', 'int32']],
    ['LPCTSTR', [_UNICODE_HOLDER, LPCWSTR, LPCSTR]],
    ['LPHANDLE', [_WIN64_HOLDER, 'uint64*', 'uint32*']],
    ['LPTSTR', [_UNICODE_HOLDER, LPWSTR, 'uint8*']],
    ['PCTSTR', [_WIN64_HOLDER, LPCWSTR, LPCSTR]],
    ['PHANDLE', [_WIN64_HOLDER, 'uint64**', 'uint32**']],
    ['PHKEY', [_WIN64_HOLDER, 'uint64*', 'uint32*']],
    ['POINTER_32', [_WIN64_HOLDER, 'uint32*', 'uint32*']],
    ['POINTER_64', [_WIN64_HOLDER, 'uint64*', 'uint32*']],
    ['PTBYTE', [_UNICODE_HOLDER, 'int16*', 'int8*']],
    ['PTCHAR', [_UNICODE_HOLDER, 'uint16*', 'uint8*']],
    ['PTSTR', [_UNICODE_HOLDER, LPWSTR, LPSTR]],
    ['TBYTE', [_UNICODE_HOLDER, 'int16', 'int8']],
    ['TCHAR', [_UNICODE_HOLDER, WCHAR, 'uint8']],
    ['UHALF_PTR', [_WIN64_HOLDER, 'uint32', 'uint16']],
    ['UINT_PTR', [_WIN64_HOLDER, 'uint64', 'uint32']],
    ['ULONG_PTR', [_WIN64_HOLDER, 'uint64', 'uint32']],
]);

/* eslint-disable id-length */
const W = parse_windef(windef, macroMap);
/**
 * Struct usage:
 *
 * import * as Struct from 'ref-struct';
 * import { DStruct as DS, DModel as M } from 'win32-api';
 *
 * const point: M.PointStruct = new Struct(DS.POINT)();
 * point.x = 100;
 * point.y = 200;
 * // const buf = point.ref()
 *
 */
/** https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-alttabinfo */
const ALTTABINFO = {
    cbSize: W.DWORD,
    cItems: W.INT,
    cColumns: W.INT,
    cRows: W.INT,
    iColFocus: W.INT,
    iRowFocus: W.INT,
    cxItem: W.INT,
    cyItem: W.INT,
    ptStart: W.POINT,
};
/** https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-copydatastruct */
const COPYDATASTRUCT = {
    dwData: W.ULONG_PTR,
    cbData: W.DWORD,
    lpData: W.PVOID,
};
/** https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-taghardwareinput */
const HARDWAREINPUT = {
    uMsg: W.DWORD,
    wParamL: W.WORD,
    wParamH: W.WORD,
};
const INITCOMMONCONTROLSEX$1 = {
    dwSize: W.DWORD,
    dwICC: W.DWORD,
};
/** https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-tagkeybdinput */
const KEYBDINPUT = {
    wVk: W.WORD,
    wScan: W.WORD,
    dwFlags: W.DWORD,
    time: W.DWORD,
    dwExtraInfo: W.ULONG_PTR,
};
/** https://docs.microsoft.com/en-us/windows/desktop/api/winuser/ns-winuser-tagmouseinput */
const MOUSEINPUT = {
    dx: W.LONG,
    dy: W.LONG,
    mouseData: W.DWORD,
    dwFlags: W.DWORD,
    time: W.DWORD,
    dwExtraInfo: W.ULONG_PTR,
};
/** https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-msg */
const MSG$1 = {
    hwnd: W.HWND,
    message: W.UINT,
    wParam: W.WPARAM,
    lParam: W.LPARAM,
    time: W.DWORD,
    pt: W.POINT,
    lPrivate: W.DWORD,
};
// https://msdn.microsoft.com/en-us/library/windows/desktop/dd162805(v=vs.85).aspx
const POINT$1 = {
    x: W.LONG,
    y: W.LONG,
};
const PROCESS_BASIC_INFORMATION = {
    Reserved1: W.PVOID,
    PebBaseAddress: W.PVOID,
    Reserved2: W.PVOID,
    UniqueProcessId: W.ULONG_PTR,
    InheritedFromUniqueProcessId: W.PVOID,
};
const UNICODE_STRING$1 = {
    Length: W.USHORT,
    MaximumLength: W.USHORT,
    Buffer: W.PWSTR,
};
/** https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-rawhid */
const RAWHID = {
    dwSizeHid: W.DWORD,
    dwCount: W.DWORD,
    /** bRawData[1] */
    bRawData: W.BYTE,
};
/** https://docs.microsoft.com/zh-cn/windows/win32/api/winuser/ns-winuser-rawinputdevicelist */
const RAWINPUTDEVICELIST = {
    hDevice: W.HANDLE,
    dwType: W.DWORD,
};
/** https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-rawinputheader */
const RAWINPUTHEADER = {
    dwType: W.DWORD,
    dwSize: W.DWORD,
    hDevice: W.HANDLE,
    wParam: W.WPARAM,
};
/** https://docs.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-rawkeyboard */
const RAWKEYBOARD = {
    MakeCode: W.USHORT,
    Flags: W.USHORT,
    Reserved: W.USHORT,
    VKey: W.USHORT,
    Message: W.UINT,
    ExtraInformation: W.ULONG,
};
const WINDOWINFO$1 = {
    cbSize: W.DWORD,
    rcWindow: W.RECT,
    rcClient: W.RECT,
    dwStyle: W.DWORD,
    dwExStyle: W.DWORD,
    dwWindowStatus: W.DWORD,
    cxWindowBorders: W.UINT,
    cyWindowBorders: W.UINT,
    atomWindowType: W.ATOM,
    wCreatorVersion: W.WORD,
};
/** https://msdn.microsoft.com/zh-cn/library/windows/desktop/ms633577(v=vs.85).aspx */
const WNDCLASSEX$1 = {
    cbSize: W.UINT,
    style: W.UINT,
    // 'lpfnWndProc': ffi.Function('int32', ['pointer', 'uint32', 'int32', 'uint32']) ,
    lpfnWndProc: W.WNDPROC,
    cbClsExtra: W.INT,
    cbWndExtra: W.INT,
    hInstance: W.HINSTANCE,
    hIcon: W.HICON,
    hCursor: W.HCURSOR,
    hbrBackground: W.HBRUSH,
    lpszMenuName: W.LPCTSTR,
    lpszClassName: W.LPCTSTR,
    hIconSm: W.HICON,
};
const RECT$1 = {
    left: W.LONG,
    top: W.LONG,
    right: W.LONG,
    bottom: W.LONG,
};
/** https://docs.microsoft.com/en-us/windows/win32/api/minwinbase/ns-minwinbase-filetime */
const FILETIME = {
    dwLowDateTime: W.DWORD,
    dwHighDateTime: W.DWORD,
};

var dataStruct = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ALTTABINFO: ALTTABINFO,
    COPYDATASTRUCT: COPYDATASTRUCT,
    HARDWAREINPUT: HARDWAREINPUT,
    INITCOMMONCONTROLSEX: INITCOMMONCONTROLSEX$1,
    KEYBDINPUT: KEYBDINPUT,
    MOUSEINPUT: MOUSEINPUT,
    MSG: MSG$1,
    POINT: POINT$1,
    PROCESS_BASIC_INFORMATION: PROCESS_BASIC_INFORMATION,
    UNICODE_STRING: UNICODE_STRING$1,
    RAWHID: RAWHID,
    RAWINPUTDEVICELIST: RAWINPUTDEVICELIST,
    RAWINPUTHEADER: RAWINPUTHEADER,
    RAWKEYBOARD: RAWKEYBOARD,
    WINDOWINFO: WINDOWINFO$1,
    WNDCLASSEX: WNDCLASSEX$1,
    RECT: RECT$1,
    _RECT: RECT$1,
    FILETIME: FILETIME
});

/* eslint-disable id-length */
const W$1 = parse_windef(windef, macroMap);
const RID_DEVICE_INFO_DUMMYUNIONNAME = {
    mouse: W$1.INT,
    keyboard: W$1.INT,
    hid: W$1.INT,
};

var dataUnion = /*#__PURE__*/Object.freeze({
    __proto__: null,
    RID_DEVICE_INFO_DUMMYUNIONNAME: RID_DEVICE_INFO_DUMMYUNIONNAME
});

var ffi_model = /*#__PURE__*/Object.freeze({
    __proto__: null
});

/*  ---------- data types for TypeScript ----------- */

var win_model = /*#__PURE__*/Object.freeze({
    __proto__: null
});

/**
 * node-win32-def
 *
 * @author waiting
 * @license MIT
 * @link https://github.com/waitingsong/node-win32-def
 */
const DTypes = parse_windef(windef, macroMap);

export { config as Config, win_model as DModel, dataStruct as DStruct, DTypes, dataUnion as DUnion, ffi_model as FModel };
//# sourceMappingURL=index.esm.js.map
